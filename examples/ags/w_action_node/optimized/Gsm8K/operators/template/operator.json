{
    "Custom": {
        "description": "Generates anything based on customized input and instruction.",
        "interface": "custom(input: str, instruction: str) -> dict with key 'response' of type str"
    },
    "Generate": {
        "description": "Generates solution based on a problem description.",
        "interface": "generate(problem: str) -> dict with key 'response' of type str"
    },
    "ContextualGenerate": {
        "description": "Generates solution based on a problem description.",
        "interface": "contextual_generate(problem: str, context: str) -> dict with key 'response' of type str"
    },
    "Format": {
        "description": "Formats a given solution based on the problem.",
        "interface": "format(problem: str, solution: str) -> dict with key 'solution' of type str"
    },
    "Review": {
        "description": "Reviews a solution based on problem description and criteria.",
        "interface": "review(problem: str, solution: str) -> dict with key 'review_result' of type bool and key 'feedback' of type str"
    },
    "Revise": {
        "description": "Revises a solution based on problem description, solution, and review's feedback.",
        "interface": "revise(problem: str, solution: str, feedback: str) -> dict with key 'solution' of type str"
    },
    "FuEnsemble": {
        "description": "Critically evaluates multiple solutions and synthesizes an enhanced integrated solution.",
        "interface": "fu_ensemble(solutions: List[str], problem: str) -> dict with key 'solution' of type str"
    },
    "MdEnsemble": {
        "description": "Uses multiple votes to choose the best solution from a set of candidate solutions.",
        "interface": "md_ensemble(solutions: List[str], problem: str) -> dict with key 'solution' of type str"
    },
    "ScEnsemble": {
        "description": "Uses self-consistency to improve the selection of the best solution.",
        "interface": "sc_ensemble(solutions: List[str], problem: str) -> dict with key 'solution' of type str"
    },
    "Rephrase": {
        "description": "Rephrases a problem description.",
        "interface": "rephrase(problem: str) -> dict with key 'rephrased_problem' of type str"
    }
}